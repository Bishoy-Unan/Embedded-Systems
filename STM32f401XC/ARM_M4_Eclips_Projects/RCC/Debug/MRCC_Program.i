# 1 "../src/MRCC_Program.c"
# 1 "E:\\ITI_9_Months\\EmbeddedSystems\\Tourkey\\workspace\\RCC\\Debug//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 201112L
#define __STDC_UTF_16__ 1
#define __STDC_UTF_32__ 1
#define __STDC_HOSTED__ 0
#define __GNUC__ 5
#define __GNUC_MINOR__ 4
#define __GNUC_PATCHLEVEL__ 1
#define __VERSION__ "5.4.1 20160919 (release) [ARM/embedded-5-branch revision 240496]"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __OPTIMIZE__ 1
#define __FINITE_MATH_ONLY__ 0
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 8
#define __SIZEOF_SIZE_T__ 4
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 8
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 4
#define __SIZE_TYPE__ unsigned int
#define __PTRDIFF_TYPE__ int
#define __WCHAR_TYPE__ unsigned int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long long int
#define __UINTMAX_TYPE__ long long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ long unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ long int
#define __INT64_TYPE__ long long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ long unsigned int
#define __UINT64_TYPE__ long long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ long int
#define __INT_LEAST64_TYPE__ long long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ long unsigned int
#define __UINT_LEAST64_TYPE__ long long unsigned int
#define __INT_FAST8_TYPE__ int
#define __INT_FAST16_TYPE__ int
#define __INT_FAST32_TYPE__ int
#define __INT_FAST64_TYPE__ long long int
#define __UINT_FAST8_TYPE__ unsigned int
#define __UINT_FAST16_TYPE__ unsigned int
#define __UINT_FAST32_TYPE__ unsigned int
#define __UINT_FAST64_TYPE__ long long unsigned int
#define __INTPTR_TYPE__ int
#define __UINTPTR_TYPE__ unsigned int
#define __has_include(STR) __has_include__(STR)
#define __has_include_next(STR) __has_include_next__(STR)
#define __GXX_ABI_VERSION 1009
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0xffffffffU
#define __WCHAR_MIN__ 0U
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffff
#define __SIZE_MAX__ 0xffffffffU
#define __INTMAX_MAX__ 0x7fffffffffffffffLL
#define __INTMAX_C(c) c ## LL
#define __UINTMAX_MAX__ 0xffffffffffffffffULL
#define __UINTMAX_C(c) c ## ULL
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffffL
#define __INT64_MAX__ 0x7fffffffffffffffLL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffUL
#define __UINT64_MAX__ 0xffffffffffffffffULL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST32_MAX__ 0x7fffffffL
#define __INT32_C(c) c ## L
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
#define __INT64_C(c) c ## LL
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffUL
#define __UINT32_C(c) c ## UL
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
#define __UINT64_C(c) c ## ULL
#define __INT_FAST8_MAX__ 0x7fffffff
#define __INT_FAST16_MAX__ 0x7fffffff
#define __INT_FAST32_MAX__ 0x7fffffff
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
#define __UINT_FAST8_MAX__ 0xffffffffU
#define __UINT_FAST16_MAX__ 0xffffffffU
#define __UINT_FAST32_MAX__ 0xffffffffU
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
#define __INTPTR_MAX__ 0x7fffffff
#define __UINTPTR_MAX__ 0xffffffffU
#define __GCC_IEC_559 0
#define __GCC_IEC_559_COMPLEX 0
#define __FLT_EVAL_METHOD__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.4028234663852886e+38F
#define __FLT_MIN__ 1.1754943508222875e-38F
#define __FLT_EPSILON__ 1.1920928955078125e-7F
#define __FLT_DENORM_MIN__ 1.4012984643248171e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ ((double)1.7976931348623157e+308L)
#define __DBL_MIN__ ((double)2.2250738585072014e-308L)
#define __DBL_EPSILON__ ((double)2.2204460492503131e-16L)
#define __DBL_DENORM_MIN__ ((double)4.9406564584124654e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 53
#define __LDBL_DIG__ 15
#define __LDBL_MIN_EXP__ (-1021)
#define __LDBL_MIN_10_EXP__ (-307)
#define __LDBL_MAX_EXP__ 1024
#define __LDBL_MAX_10_EXP__ 308
#define __DECIMAL_DIG__ 17
#define __LDBL_MAX__ 1.7976931348623157e+308L
#define __LDBL_MIN__ 2.2250738585072014e-308L
#define __LDBL_EPSILON__ 2.2204460492503131e-16L
#define __LDBL_DENORM_MIN__ 4.9406564584124654e-324L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __SFRACT_FBIT__ 7
#define __SFRACT_IBIT__ 0
#define __SFRACT_MIN__ (-0.5HR-0.5HR)
#define __SFRACT_MAX__ 0X7FP-7HR
#define __SFRACT_EPSILON__ 0x1P-7HR
#define __USFRACT_FBIT__ 8
#define __USFRACT_IBIT__ 0
#define __USFRACT_MIN__ 0.0UHR
#define __USFRACT_MAX__ 0XFFP-8UHR
#define __USFRACT_EPSILON__ 0x1P-8UHR
#define __FRACT_FBIT__ 15
#define __FRACT_IBIT__ 0
#define __FRACT_MIN__ (-0.5R-0.5R)
#define __FRACT_MAX__ 0X7FFFP-15R
#define __FRACT_EPSILON__ 0x1P-15R
#define __UFRACT_FBIT__ 16
#define __UFRACT_IBIT__ 0
#define __UFRACT_MIN__ 0.0UR
#define __UFRACT_MAX__ 0XFFFFP-16UR
#define __UFRACT_EPSILON__ 0x1P-16UR
#define __LFRACT_FBIT__ 31
#define __LFRACT_IBIT__ 0
#define __LFRACT_MIN__ (-0.5LR-0.5LR)
#define __LFRACT_MAX__ 0X7FFFFFFFP-31LR
#define __LFRACT_EPSILON__ 0x1P-31LR
#define __ULFRACT_FBIT__ 32
#define __ULFRACT_IBIT__ 0
#define __ULFRACT_MIN__ 0.0ULR
#define __ULFRACT_MAX__ 0XFFFFFFFFP-32ULR
#define __ULFRACT_EPSILON__ 0x1P-32ULR
#define __LLFRACT_FBIT__ 63
#define __LLFRACT_IBIT__ 0
#define __LLFRACT_MIN__ (-0.5LLR-0.5LLR)
#define __LLFRACT_MAX__ 0X7FFFFFFFFFFFFFFFP-63LLR
#define __LLFRACT_EPSILON__ 0x1P-63LLR
#define __ULLFRACT_FBIT__ 64
#define __ULLFRACT_IBIT__ 0
#define __ULLFRACT_MIN__ 0.0ULLR
#define __ULLFRACT_MAX__ 0XFFFFFFFFFFFFFFFFP-64ULLR
#define __ULLFRACT_EPSILON__ 0x1P-64ULLR
#define __SACCUM_FBIT__ 7
#define __SACCUM_IBIT__ 8
#define __SACCUM_MIN__ (-0X1P7HK-0X1P7HK)
#define __SACCUM_MAX__ 0X7FFFP-7HK
#define __SACCUM_EPSILON__ 0x1P-7HK
#define __USACCUM_FBIT__ 8
#define __USACCUM_IBIT__ 8
#define __USACCUM_MIN__ 0.0UHK
#define __USACCUM_MAX__ 0XFFFFP-8UHK
#define __USACCUM_EPSILON__ 0x1P-8UHK
#define __ACCUM_FBIT__ 15
#define __ACCUM_IBIT__ 16
#define __ACCUM_MIN__ (-0X1P15K-0X1P15K)
#define __ACCUM_MAX__ 0X7FFFFFFFP-15K
#define __ACCUM_EPSILON__ 0x1P-15K
#define __UACCUM_FBIT__ 16
#define __UACCUM_IBIT__ 16
#define __UACCUM_MIN__ 0.0UK
#define __UACCUM_MAX__ 0XFFFFFFFFP-16UK
#define __UACCUM_EPSILON__ 0x1P-16UK
#define __LACCUM_FBIT__ 31
#define __LACCUM_IBIT__ 32
#define __LACCUM_MIN__ (-0X1P31LK-0X1P31LK)
#define __LACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LK
#define __LACCUM_EPSILON__ 0x1P-31LK
#define __ULACCUM_FBIT__ 32
#define __ULACCUM_IBIT__ 32
#define __ULACCUM_MIN__ 0.0ULK
#define __ULACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULK
#define __ULACCUM_EPSILON__ 0x1P-32ULK
#define __LLACCUM_FBIT__ 31
#define __LLACCUM_IBIT__ 32
#define __LLACCUM_MIN__ (-0X1P31LLK-0X1P31LLK)
#define __LLACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LLK
#define __LLACCUM_EPSILON__ 0x1P-31LLK
#define __ULLACCUM_FBIT__ 32
#define __ULLACCUM_IBIT__ 32
#define __ULLACCUM_MIN__ 0.0ULLK
#define __ULLACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULLK
#define __ULLACCUM_EPSILON__ 0x1P-32ULLK
#define __QQ_FBIT__ 7
#define __QQ_IBIT__ 0
#define __HQ_FBIT__ 15
#define __HQ_IBIT__ 0
#define __SQ_FBIT__ 31
#define __SQ_IBIT__ 0
#define __DQ_FBIT__ 63
#define __DQ_IBIT__ 0
#define __TQ_FBIT__ 127
#define __TQ_IBIT__ 0
#define __UQQ_FBIT__ 8
#define __UQQ_IBIT__ 0
#define __UHQ_FBIT__ 16
#define __UHQ_IBIT__ 0
#define __USQ_FBIT__ 32
#define __USQ_IBIT__ 0
#define __UDQ_FBIT__ 64
#define __UDQ_IBIT__ 0
#define __UTQ_FBIT__ 128
#define __UTQ_IBIT__ 0
#define __HA_FBIT__ 7
#define __HA_IBIT__ 8
#define __SA_FBIT__ 15
#define __SA_IBIT__ 16
#define __DA_FBIT__ 31
#define __DA_IBIT__ 32
#define __TA_FBIT__ 63
#define __TA_IBIT__ 64
#define __UHA_FBIT__ 8
#define __UHA_IBIT__ 8
#define __USA_FBIT__ 16
#define __USA_IBIT__ 16
#define __UDA_FBIT__ 32
#define __UDA_IBIT__ 32
#define __UTA_FBIT__ 64
#define __UTA_IBIT__ 64
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 1
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 4
#define __ARM_FEATURE_DSP 1
#define __ARM_FEATURE_QBIT 1
#define __ARM_FEATURE_SAT 1
#define __ARM_FEATURE_UNALIGNED 1
#define __ARM_32BIT_STATE 1
#define __ARM_FEATURE_LDREX 7
#define __ARM_FEATURE_CLZ 1
#define __ARM_FEATURE_SIMD32 1
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 4
#define __ARM_ARCH_PROFILE 77
#define __arm__ 1
#define __ARM_ARCH 7
#define __APCS_32__ 1
#define __thumb__ 1
#define __thumb2__ 1
#define __ARM_ARCH_ISA_THUMB 2
#define __ARMEL__ 1
#define __THUMBEL__ 1
#define __SOFTFP__ 1
#define __VFP_FP__ 1
#define __THUMB_INTERWORK__ 1
#define __ARM_ARCH_7EM__ 1
#define __ARM_PCS 1
#define __ARM_EABI__ 1
#define __ARM_ARCH_EXT_IDIV__ 1
#define __ARM_FEATURE_IDIV 1
#define __ARM_ASM_SYNTAX_UNIFIED__ 1
#define __GXX_TYPEINFO_EQUALITY_INLINE 0
#define __ELF__ 1
# 1 "<command-line>"
#define __USES_INITFINI__ 1
#define DEBUG 1
#define USE_FULL_ASSERT 1
#define TRACE 1
#define OS_USE_TRACE_SEMIHOSTING_DEBUG 1
#define STM32F401xC 1
#define USE_HAL_DRIVER 1
#define HSE_VALUE 25000000
# 1 "../src/MRCC_Program.c"
# 15 "../src/MRCC_Program.c"
# 1 "../src/../include/STD_TYPES.h" 1
# 13 "../src/../include/STD_TYPES.h"
#define STD_TYPES_H_ 

typedef unsigned char u8 ;
typedef unsigned short int u16 ;
typedef unsigned int u32 ;
typedef unsigned long long int u64 ;

typedef signed char s8 ;
typedef signed short int s16 ;
typedef signed int s32 ;
typedef signed long long int s64 ;

typedef float f32 ;

typedef double f64 ;

typedef long double f96 ;
# 16 "../src/MRCC_Program.c" 2
# 1 "../src/../include/MRCC_Interface.h" 1
# 16 "../src/../include/MRCC_Interface.h"
#define MRCC_INTERFACE_H_ 

# 1 "../src/../include/STD_TYPES.h" 1
# 19 "../src/../include/MRCC_Interface.h" 2
# 27 "../src/../include/MRCC_Interface.h"
#define GPIOA_RCC 0UL
#define GPIOB_RCC 1UL
#define GPIOC_RCC 2UL
#define GPIOD_RCC 3UL
#define GPIOE_RCC 4UL
#define GPIOH_RCC 7UL
#define CRC_RCC 12UL
#define DMA1_RCC 21UL
#define DMA2_RCC 22UL


#define OTGFS_RCC 7





#define TIM2_RCC 0UL
#define TIM3_RCC 1UL
#define TIM4_RCC 2UL
#define TIM5_RCC 3UL
#define WWDG_RCC 11UL
#define SPI2_RCC 14UL
#define SPI3_RCC 15UL
#define USART2_RCC 17UL
#define I2C1_RCC 21UL
#define I2C2_RCC 22UL
#define I2C3_RCC 23UL
#define PWR_RCC 28UL





#define TIM1_RCC 0UL
#define USART1_RCC 4UL
#define USART6_RCC 5UL
#define ADC1_RCC 8UL
#define SDIO_RCC 11UL
#define SPI1_RCC 12UL
#define SPI4_RCC 13UL
#define SYSCFG_RCC 14UL
#define TIM9_RCC 16UL
#define TIM10_RCC 17UL
#define TIM11_RCC 18UL


#define MASK_AHB_PRESCALER 0xFFFFFF0F
#define AHB_SYSTEM_CLOCK_NOT_DIVIDED 0X00000000
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_2 0X00000080
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_4 0X00000090
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_8 0X000000A0
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_16 0X000000B0
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_64 0X000000C0
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_128 0X000000D0
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_256 0X000000E0
#define AHB_SYSTEM_CLOCK_DIVIDED_BY_512 0X000000F0


#define MASK_APB1_PRESCALER 0xFFFFE3FF
#define APB1_AHB_CLOCK_NOT_DIVIDED 0X00000000
#define APB1_AHB__CLOCK_DIVIDED_BY_2 0X00001000
#define APB1_AHB__CLOCK_DIVIDED_BY_4 0X00001400
#define APB1_AHB__CLOCK_DIVIDED_BY_8 0X00001800
#define APB1_AHB__CLOCK_DIVIDED_BY_16 0X00001C00


#define MASK_APB2_PRESCALER 0xFFFF1FFF
#define APB2_AHB_CLOCK_NOT_DIVIDED 0X00000000
#define APB2_AHB__CLOCK_DIVIDED_BY_2 0X00008000
#define APB2_AHB__CLOCK_DIVIDED_BY_4 0X0000A000
#define APB2_AHB__CLOCK_DIVIDED_BY_8 0X0000C000
#define APB2_AHB__CLOCK_DIVIDED_BY_16 0X0000E000





typedef enum {
  RCC_enuOK,
  RCC_enuNOK
}RCC_enuErrorStatus_t;

typedef enum
{
 RCC_AHB1 = 0 ,
 RCC_AHB2 ,
 RCC_APB1 ,
 RCC_APB2
}RCC_enuBus_t;

typedef enum
{
 RCC_HSI = 0 ,
 RCC_HSE ,
 RCC_PLL
}RCC_enuSysClk_t;

typedef enum
{
 RCC_CLK_ON ,
 RCC_CLK_OFF
}RCC_enuClkStatus_t;

typedef enum
{
 PLL_HSI_SRC ,
 PLL_HSE_SRC
}RCC_enuPLLSRC_t;

typedef struct{
  RCC_enuPLLSRC_t RCC_strPLLSCR;
  u32 RCC_strPLL_M;
  u32 RCC_strPLL_N;
  u32 RCC_strPLL_P;
  u32 RCC_strPLL_Q;
}RCC_structCLKPLL_t;
# 156 "../src/../include/MRCC_Interface.h"
RCC_enuErrorStatus_t RCC_enuControlClk (RCC_enuSysClk_t Copy_enuClockSystem,RCC_enuClkStatus_t Copy_enuClkStatus);
# 166 "../src/../include/MRCC_Interface.h"
RCC_enuErrorStatus_t RCC_enuSelectSystemClk (RCC_enuSysClk_t Copy_enuSystemClock);
# 176 "../src/../include/MRCC_Interface.h"
RCC_enuErrorStatus_t RCC_enuEnablePeripheralClock (RCC_enuBus_t Copy_enuPeripheralBus, u8 Copy_u8PeripheralNumber);
# 186 "../src/../include/MRCC_Interface.h"
RCC_enuErrorStatus_t RCC_enuDisablePeripheralClock (RCC_enuBus_t Copy_enuPeripheralBus, u8 Copy_u8PeripheralNumber);
# 196 "../src/../include/MRCC_Interface.h"
RCC_enuErrorStatus_t RCC_enuConfigPLL (RCC_structCLKPLL_t * Copy_structPLLCongif);
# 206 "../src/../include/MRCC_Interface.h"
RCC_enuErrorStatus_t RCC_enuControlBusesPrescaler (RCC_enuBus_t Copy_enuBus ,u8 Copy_u32APB2Prescaler);
# 17 "../src/MRCC_Program.c" 2
# 1 "../src/../include/MRCC_Private.h" 1
# 17 "../src/../include/MRCC_Private.h"
#define MRCC_PRIVATE_H_ 



#define RCC_BASE_ADDRESS 0x40023800




#define RCC_CR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x00))
#define RCC_PLLCFGR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x04))
#define RCC_CFGR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x08))
#define RCC_CIR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x0C))
#define RCC_AHB1RSTR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x10))
#define RCC_AHB2RSTR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x14))
#define RCC_APB1RSTR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x20))
#define RCC_APB2RSTR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x24))
#define RCC_AHB1ENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x30))
#define RCC_AHB2ENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x34))
#define RCC_APB1ENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x40))
#define RCC_APB2ENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0x44))
#define RCC_AHB1LPENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X50))
#define RCC_AHB2LPENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X54))
#define RCC_APB1LPENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X60))
#define RCC_APB2LPENR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X64))
#define RCC_BDCR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X70))
#define RCC_CSR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X74))
#define RCC_SSCGR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X80))
#define RCC_PLLI2SCFGR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X84))
#define RCC_DCKCFGR *((volatile u32 *)(RCC_BASE_ADDRESS + 0X8C))





#define RCC_HSI 0x00000000
#define RCC_HSE 0x00000001
#define RCC_PLL 0x00000002




#define RCC_HSE_SRC_RC 0UL
#define RCC_HSE_SRC_CRYSTAL 1UL




#define RCC_PLL_SRC_HSI 0UL
#define RCC_PLL_SRC_HSE 1UL




#define AHB1_BUS 0UL
#define AHB2_BUS 1UL
#define APB1_BUS 2UL
#define APB2_BUS 3UL
# 83 "../src/../include/MRCC_Private.h"
#define MASK_GET_SYSCLK 0x0000000C

#define MASK_HSI_ON 0x00000001
#define MASK_HSI_RDY 0x00000002
#define MASK_HSE_ON 0x00010000
#define MASK_HSE_RDY 0x00020000
#define MASK_PLL_ON 0x01000000
#define MASK_PLL_RDY 0x02000000

#define MASK_SW 0x00000003
#define MASK_GET_SWS 0x0000000C
#define MASK_SWS_HSI 0x00000000
#define MASK_SWS_HSE 0x00000004
#define MASK_SWS_PLL 0x00000008

#define MASK_GET_ON_PLL 0x01000000

#define ON 1UL
#define OFF 0UL

#define MASK_SET_PPL_M 0x0000003F
#define MASK_SET_PPL_N 0x00007FC0
#define MASK_SET_PPL_P 0x00030000
#define MASK_SET_PPL_Q 0x0F000000
#define MASK_SET_PPL_SRC 0x00400000

#define SHIFT_PLL_M 0
#define SHIFT_PLL_N 6
#define SHIFT_PLL_P 16
#define SHIFT_PLL_Q 24
#define SHIFT_PLL_SRC 22
# 18 "../src/MRCC_Program.c" 2

RCC_enuErrorStatus_t RCC_enuControlClk (RCC_enuSysClk_t Copy_enuClockSystem,RCC_enuClkStatus_t Copy_enuClkStatus)
{
    RCC_enuErrorStatus_t Ret_enuErrorStatus = RCC_enuOK ;



    u32 Loc_u32CurrSystemCLOCK = ((*((volatile u32 *)(0x40023800 + 0x08)) & 0x0000000C)>>2);



    u32 Loc_u32TimeOut = 0;




    if((Copy_enuClockSystem > 0x00000002) || (Copy_enuClockSystem < 0x00000000))
      {
            Ret_enuErrorStatus = RCC_enuNOK;
      }



    else if(Loc_u32CurrSystemCLOCK == Copy_enuClockSystem)
      {
            Ret_enuErrorStatus = RCC_enuNOK;
      }
    else
    {
        switch(Copy_enuClockSystem)
        {



            case 0x00000000 :



                    if(Copy_enuClkStatus == RCC_CLK_ON)
                        {
                            *((volatile u32 *)(0x40023800 + 0x00)) |= (0x00000001);
                        }



                    else if(Copy_enuClkStatus == RCC_CLK_OFF)
                        {
                            *((volatile u32 *)(0x40023800 + 0x00)) &= (~0x00000001);
                        }
                    else
                         Ret_enuErrorStatus = RCC_enuNOK;



                    while(((*((volatile u32 *)(0x40023800 + 0x00)) & 0x00000002) == 0) && Loc_u32TimeOut < 10000)
                    {
                        Loc_u32TimeOut ++ ;
                    }



                    if(Loc_u32TimeOut >= 10000)
                    {
                         Ret_enuErrorStatus = RCC_enuNOK;
                    }
            break ;



            case 0x00000001 :



                    if(Copy_enuClkStatus == RCC_CLK_ON)
                        {
                            *((volatile u32 *)(0x40023800 + 0x00)) |= (0x00010000);
                        }



                    else if(Copy_enuClkStatus == RCC_CLK_OFF)
                        {
                            *((volatile u32 *)(0x40023800 + 0x00)) &= (~0x00010000);
                        }
                    else
                         Ret_enuErrorStatus = RCC_enuNOK;



                    while(((*((volatile u32 *)(0x40023800 + 0x00)) & 0x00020000) == 0) && Loc_u32TimeOut < 10000)
                    {
                        Loc_u32TimeOut ++ ;
                    }



                    if(Loc_u32TimeOut >= 10000)
                    {
                         Ret_enuErrorStatus = RCC_enuNOK;
                    }
            break ;



            case 0x00000002 :



                    if(Copy_enuClkStatus == RCC_CLK_ON)
                        {
                            *((volatile u32 *)(0x40023800 + 0x00)) |= (0x01000000);
                        }



                    else if(Copy_enuClkStatus == RCC_CLK_OFF)
                        {
                            *((volatile u32 *)(0x40023800 + 0x00)) &= (~0x01000000);
                        }
                    else
                         Ret_enuErrorStatus = RCC_enuNOK;



                    while(((*((volatile u32 *)(0x40023800 + 0x00)) & 0x02000000) == 0) && Loc_u32TimeOut < 10000)
                    {
                        Loc_u32TimeOut ++ ;
                    }



                    if(Loc_u32TimeOut >= 10000)
                    {
                         Ret_enuErrorStatus = RCC_enuNOK;
                    }
            break ;
            default :
            break ;
        }
    }



return Ret_enuErrorStatus ;
}

RCC_enuErrorStatus_t RCC_enuSelectSystemClk (RCC_enuSysClk_t Copy_enuSystemClock)
{
     RCC_enuErrorStatus_t Ret_enuErrorStatus = RCC_enuOK ;

     u32 Loc_u32CFGR_TempRegister;



     u32 Loc_u32TimeOut = 0;



    if(!(Copy_enuSystemClock >= 0x00000000) && (Copy_enuSystemClock <= 0x00000002))
      {
            Ret_enuErrorStatus = RCC_enuNOK;
      }
    else
    {
        switch(Copy_enuSystemClock)
        {



            case 0x00000000 :

                      if( ((*((volatile u32 *)(0x40023800 + 0x00)) & 0x00000001) == 0x00000001) )
                      {

                          if((*((volatile u32 *)(0x40023800 + 0x00)) & 0x00000002) == 0x00000002)
                          {
                            Loc_u32CFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x08)) ;
                            Loc_u32CFGR_TempRegister &= (~0x00000003) ;
                            Loc_u32CFGR_TempRegister |= 0x00000000 ;
                            *((volatile u32 *)(0x40023800 + 0x08)) = Loc_u32CFGR_TempRegister ;

                            while( ((*((volatile u32 *)(0x40023800 + 0x08)) & 0x0000000C) != 0x00000000) && (Loc_u32TimeOut<100000))
                            {
              Loc_u32TimeOut++;
             }
                            if( Loc_u32TimeOut >= 100000 )
                            {

              Ret_enuErrorStatus = RCC_enuNOK;
             }

                          }
                          else
                              Ret_enuErrorStatus = RCC_enuNOK;
                      }
                      else
                              Ret_enuErrorStatus = RCC_enuNOK;
            break;
            case 0x00000001 :

                      if( ((*((volatile u32 *)(0x40023800 + 0x00)) & 0x00010000) == 0x00010000) )
                      {

                          if((*((volatile u32 *)(0x40023800 + 0x00)) & 0x00020000) == 0x00020000)
                          {
                            Loc_u32CFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x08)) ;
                            Loc_u32CFGR_TempRegister &= (~0x00000003) ;
                            Loc_u32CFGR_TempRegister |= 0x00000001 ;
                            *((volatile u32 *)(0x40023800 + 0x08)) = Loc_u32CFGR_TempRegister ;

                            while( ((*((volatile u32 *)(0x40023800 + 0x08)) & 0x0000000C) != 0x00000004) && (Loc_u32TimeOut<100000))
                            {
              Loc_u32TimeOut++;
             }
                            if( Loc_u32TimeOut >= 100000 )
                            {

              Ret_enuErrorStatus = RCC_enuNOK;
             }


                          }
                          else
                              Ret_enuErrorStatus = RCC_enuNOK;
                      }
                      else
                              Ret_enuErrorStatus = RCC_enuNOK;
            break;
            case 0x00000002 :

                      if( ((*((volatile u32 *)(0x40023800 + 0x00)) & 0x01000000) == 0x01000000) )
                      {

                          if((*((volatile u32 *)(0x40023800 + 0x00)) & 0x02000000) == 0x02000000)
                          {
                            Loc_u32CFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x08)) ;
                            Loc_u32CFGR_TempRegister &= (~0x00000003) ;
                            Loc_u32CFGR_TempRegister |= 0x00000002 ;
                            *((volatile u32 *)(0x40023800 + 0x08)) = Loc_u32CFGR_TempRegister ;

                            while( ((*((volatile u32 *)(0x40023800 + 0x08)) & 0x0000000C) != 0x00000008) && (Loc_u32TimeOut<100000))
                            {
              Loc_u32TimeOut++;
             }
                            if( Loc_u32TimeOut >= 100000 )
                            {

              Ret_enuErrorStatus = RCC_enuNOK;
             }


                          }
                          else
                              Ret_enuErrorStatus = RCC_enuNOK;
                      }
                      else
                              Ret_enuErrorStatus = RCC_enuNOK;
            break;
            default :
            break;
        }
    }

return Ret_enuErrorStatus ;
}

RCC_enuErrorStatus_t RCC_enuEnablePeripheralClock (RCC_enuBus_t Copy_enuPeripheralBus, u8 Copy_u8PeripheralNumber)
{
     RCC_enuErrorStatus_t Ret_enuErrorStatus = RCC_enuOK ;



     if( Copy_enuPeripheralBus < RCC_AHB1 && Copy_enuPeripheralBus > RCC_APB2 )
     {
         Ret_enuErrorStatus = RCC_enuNOK ;
     }
     else
     {
        switch(Copy_enuPeripheralBus)
        {
            case RCC_AHB1 :
                         *((volatile u32 *)(0x40023800 + 0x30)) |= (1<<Copy_u8PeripheralNumber);
            break;
            case RCC_AHB2 :
                         *((volatile u32 *)(0x40023800 + 0x34)) |= (1<<Copy_u8PeripheralNumber);
            break;
            case RCC_APB1 :
                         *((volatile u32 *)(0x40023800 + 0x40)) |= (1<<Copy_u8PeripheralNumber);
            break;
            case RCC_APB2 :
                         *((volatile u32 *)(0x40023800 + 0x44)) |= (1<<Copy_u8PeripheralNumber);
            break;
            default :
            break;
        }

     }



return Ret_enuErrorStatus ;
}

RCC_enuErrorStatus_t RCC_enuDisablePeripheralClock (RCC_enuBus_t Copy_enuPeripheralBus, u8 Copy_u8PeripheralNumber)
{
     RCC_enuErrorStatus_t Ret_enuErrorStatus = RCC_enuOK ;




     if( Copy_enuPeripheralBus < RCC_AHB1 && Copy_enuPeripheralBus > RCC_APB2 )
     {
         Ret_enuErrorStatus = RCC_enuNOK ;
     }
     else
     {
        switch(Copy_enuPeripheralBus)
        {
            case RCC_AHB1 :
                         *((volatile u32 *)(0x40023800 + 0x30)) &= (~(1<<Copy_u8PeripheralNumber));
            break;
            case RCC_AHB2 :
                         *((volatile u32 *)(0x40023800 + 0x34)) &= (~(1<<Copy_u8PeripheralNumber));
            break;
            case RCC_APB1 :
                         *((volatile u32 *)(0x40023800 + 0x40)) &= (~(1<<Copy_u8PeripheralNumber));
            break;
            case RCC_APB2 :
                         *((volatile u32 *)(0x40023800 + 0x44)) &= (~(1<<Copy_u8PeripheralNumber));
            break;
            default :
            break;
        }

     }


return Ret_enuErrorStatus ;
}

RCC_enuErrorStatus_t RCC_enuConfigPLL (RCC_structCLKPLL_t * Copy_structPLLCongif)
{
     RCC_enuErrorStatus_t Ret_enuErrorStatus = RCC_enuOK ;

       u32 Loc_u32PLLCFGR_TempRegister;


         if(( *((volatile u32 *)(0x40023800 + 0x00)) & 0x01000000) == 1UL)
         {
                Ret_enuErrorStatus = RCC_enuNOK ;
         }

         else if(Copy_structPLLCongif->RCC_strPLLSCR > PLL_HSE_SRC || Copy_structPLLCongif->RCC_strPLLSCR < PLL_HSI_SRC)
         {
                Ret_enuErrorStatus = RCC_enuNOK ;
         }

         else if(Copy_structPLLCongif->RCC_strPLL_M < 2 || Copy_structPLLCongif->RCC_strPLL_M > 63)
         {
                Ret_enuErrorStatus = RCC_enuNOK ;
         }

         else if(Copy_structPLLCongif->RCC_strPLL_N < 192 || Copy_structPLLCongif->RCC_strPLL_N > 432)
         {
                Ret_enuErrorStatus = RCC_enuNOK ;
         }

         else if((Copy_structPLLCongif->RCC_strPLL_P != 2) && (Copy_structPLLCongif->RCC_strPLL_P != 4) && (Copy_structPLLCongif->RCC_strPLL_P != 6) && (Copy_structPLLCongif->RCC_strPLL_P != 8))
         {
                Ret_enuErrorStatus = RCC_enuNOK ;
         }


         else if(Copy_structPLLCongif->RCC_strPLL_P < 2 || Copy_structPLLCongif->RCC_strPLL_P > 15)
         {
                Ret_enuErrorStatus = RCC_enuNOK ;
         }
         else
         {


    Loc_u32PLLCFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x04)) ;
    Loc_u32PLLCFGR_TempRegister &= ~0x0000003F ;
    Loc_u32PLLCFGR_TempRegister |= ( Copy_structPLLCongif->RCC_strPLL_M << 0 ) ;
    *((volatile u32 *)(0x40023800 + 0x04)) = Loc_u32PLLCFGR_TempRegister ;


    Loc_u32PLLCFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x04)) ;
    Loc_u32PLLCFGR_TempRegister &= ~0x00007FC0 ;
    Loc_u32PLLCFGR_TempRegister |= ( Copy_structPLLCongif->RCC_strPLL_N << 6 ) ;
    *((volatile u32 *)(0x40023800 + 0x04)) = Loc_u32PLLCFGR_TempRegister ;


    Loc_u32PLLCFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x04)) ;
    Loc_u32PLLCFGR_TempRegister &= ~0x00030000 ;
    Loc_u32PLLCFGR_TempRegister |= ( Copy_structPLLCongif->RCC_strPLL_P << 16 ) ;
    *((volatile u32 *)(0x40023800 + 0x04)) = Loc_u32PLLCFGR_TempRegister ;


    Loc_u32PLLCFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x04)) ;
    Loc_u32PLLCFGR_TempRegister &= ~ 0x0F000000 ;
    Loc_u32PLLCFGR_TempRegister |= ( Copy_structPLLCongif->RCC_strPLL_Q << 24 ) ;
    *((volatile u32 *)(0x40023800 + 0x04)) = Loc_u32PLLCFGR_TempRegister ;


    Loc_u32PLLCFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x04)) ;
    Loc_u32PLLCFGR_TempRegister &= ~0x00400000 ;
    Loc_u32PLLCFGR_TempRegister |= ( Copy_structPLLCongif->RCC_strPLLSCR << 22 ) ;
    *((volatile u32 *)(0x40023800 + 0x04)) = Loc_u32PLLCFGR_TempRegister ;
         }




return Ret_enuErrorStatus ;
}

RCC_enuErrorStatus_t RCC_enuControlBusesPrescaler (RCC_enuBus_t Copy_enuPeripheralBus ,u8 Copy_u32APB2Prescaler)
{
     RCC_enuErrorStatus_t Ret_enuErrorStatus = RCC_enuOK ;

      u32 Loc_u32CFGR_TempRegister;



     if( Copy_enuPeripheralBus < RCC_AHB1 && Copy_enuPeripheralBus > RCC_APB2 )
     {
         Ret_enuErrorStatus = RCC_enuNOK ;
     }
     else
     {
        switch(Copy_enuPeripheralBus)
        {
            case RCC_AHB1 :

                            Loc_u32CFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x08));
                            Loc_u32CFGR_TempRegister &= 0xFFFFFF0F ;

                            switch(Copy_u32APB2Prescaler)
                            {
                                case 0X00000000 :
                                                    Loc_u32CFGR_TempRegister |= 0X00000000 ;
                                break;
                                case 0X00000080 :
                                                    Loc_u32CFGR_TempRegister |= 0X00000080 ;
                                break;
                                case 0X00000090 :
                                                    Loc_u32CFGR_TempRegister |= 0X00000090 ;
                                break;
                                case 0X000000A0 :
                                                    Loc_u32CFGR_TempRegister |= 0X000000A0 ;
                                break;
                                case 0X000000B0 :
                                                    Loc_u32CFGR_TempRegister |= 0X000000B0 ;
                                break;
                                case 0X000000C0 :
                                                    Loc_u32CFGR_TempRegister |= 0X000000C0 ;
                                break;
                                case 0X000000D0 :
                                                    Loc_u32CFGR_TempRegister |= 0X000000D0 ;
                                break;
                                case 0X000000E0 :
                                                    Loc_u32CFGR_TempRegister |= 0X000000E0 ;
                                break;
                                case 0X000000F0 :
                                                    Loc_u32CFGR_TempRegister |= 0X000000F0 ;
                                break;
                                default :
                                        Ret_enuErrorStatus = RCC_enuNOK ;
                                break;

                            }
                         *((volatile u32 *)(0x40023800 + 0x08)) = Loc_u32CFGR_TempRegister;

            break;
            case RCC_APB1 :
                            Loc_u32CFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x08));
                            Loc_u32CFGR_TempRegister &= 0xFFFFE3FF ;

                            switch(Copy_u32APB2Prescaler)
                            {
                                case 0X00000000 :
                                                    Loc_u32CFGR_TempRegister |= 0X00000000 ;
                                break;
                                case 0X00001000 :
                                                    Loc_u32CFGR_TempRegister |= 0X00001000 ;
                                break;
                                case 0X00001400 :
                                                    Loc_u32CFGR_TempRegister |= 0X00001400 ;
                                break;
                                case 0X00001800 :
                                                    Loc_u32CFGR_TempRegister |= 0X00001800 ;
                                break;
                                case 0X00001C00:
                                                    Loc_u32CFGR_TempRegister |= 0X00001C00 ;
                                break;
                                default :
                                        Ret_enuErrorStatus = RCC_enuNOK ;
                                break;

                            }
                         *((volatile u32 *)(0x40023800 + 0x08)) = Loc_u32CFGR_TempRegister;


            break;
            case RCC_APB2 :
                            Loc_u32CFGR_TempRegister = *((volatile u32 *)(0x40023800 + 0x08));
                            Loc_u32CFGR_TempRegister &= 0xFFFF1FFF ;

                            switch(Copy_u32APB2Prescaler)
                            {
                                case 0X00000000 :
                                                    Loc_u32CFGR_TempRegister |= 0X00000000 ;
                                break;
                                case 0X00008000 :
                                                    Loc_u32CFGR_TempRegister |= 0X00008000 ;
                                break;
                                case 0X0000A000 :
                                                    Loc_u32CFGR_TempRegister |= 0X0000A000 ;
                                break;
                                case 0X0000C000 :
                                                    Loc_u32CFGR_TempRegister |= 0X0000C000 ;
                                break;
                                case 0X0000E000:
                                                    Loc_u32CFGR_TempRegister |= 0X0000E000 ;
                                break;
                                default :
                                                    Ret_enuErrorStatus = RCC_enuNOK ;
                                break;

                            }
                         *((volatile u32 *)(0x40023800 + 0x08)) = Loc_u32CFGR_TempRegister;

            break;
            default :
            break;
        }

     }



return Ret_enuErrorStatus ;
}
