   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"_startup.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.__initialize_data,"ax",%progbits
  20              		.align	2
  21              		.global	__initialize_data
  22              		.thumb
  23              		.thumb_func
  25              	__initialize_data:
  26              	.LFB0:
  27              		.file 1 "../system/src/newlib/_startup.c"
   1:../system/src/newlib/_startup.c **** /*
   2:../system/src/newlib/_startup.c ****  * This file is part of the ÂµOS++ distribution.
   3:../system/src/newlib/_startup.c ****  *   (https://github.com/micro-os-plus)
   4:../system/src/newlib/_startup.c ****  * Copyright (c) 2014 Liviu Ionescu.
   5:../system/src/newlib/_startup.c ****  *
   6:../system/src/newlib/_startup.c ****  * Permission is hereby granted, free of charge, to any person
   7:../system/src/newlib/_startup.c ****  * obtaining a copy of this software and associated documentation
   8:../system/src/newlib/_startup.c ****  * files (the "Software"), to deal in the Software without
   9:../system/src/newlib/_startup.c ****  * restriction, including without limitation the rights to use,
  10:../system/src/newlib/_startup.c ****  * copy, modify, merge, publish, distribute, sublicense, and/or
  11:../system/src/newlib/_startup.c ****  * sell copies of the Software, and to permit persons to whom
  12:../system/src/newlib/_startup.c ****  * the Software is furnished to do so, subject to the following
  13:../system/src/newlib/_startup.c ****  * conditions:
  14:../system/src/newlib/_startup.c ****  *
  15:../system/src/newlib/_startup.c ****  * The above copyright notice and this permission notice shall be
  16:../system/src/newlib/_startup.c ****  * included in all copies or substantial portions of the Software.
  17:../system/src/newlib/_startup.c ****  *
  18:../system/src/newlib/_startup.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  19:../system/src/newlib/_startup.c ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  20:../system/src/newlib/_startup.c ****  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  21:../system/src/newlib/_startup.c ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  22:../system/src/newlib/_startup.c ****  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  23:../system/src/newlib/_startup.c ****  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  24:../system/src/newlib/_startup.c ****  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  25:../system/src/newlib/_startup.c ****  * OTHER DEALINGS IN THE SOFTWARE.
  26:../system/src/newlib/_startup.c ****  */
  27:../system/src/newlib/_startup.c **** 
  28:../system/src/newlib/_startup.c **** // ----------------------------------------------------------------------------
  29:../system/src/newlib/_startup.c **** 
  30:../system/src/newlib/_startup.c **** // This module contains the startup code for a portable embedded
  31:../system/src/newlib/_startup.c **** // C/C++ application, built with newlib.
  32:../system/src/newlib/_startup.c **** //
  33:../system/src/newlib/_startup.c **** // Control reaches here from the reset handler via jump or call.
  34:../system/src/newlib/_startup.c **** //
  35:../system/src/newlib/_startup.c **** // The actual steps performed by _start are:
  36:../system/src/newlib/_startup.c **** // - copy the initialised data region(s)
  37:../system/src/newlib/_startup.c **** // - clear the BSS region(s)
  38:../system/src/newlib/_startup.c **** // - initialise the system
  39:../system/src/newlib/_startup.c **** // - run the preinit/init array (for the C++ static constructors)
  40:../system/src/newlib/_startup.c **** // - initialise the arc/argv
  41:../system/src/newlib/_startup.c **** // - branch to main()
  42:../system/src/newlib/_startup.c **** // - run the fini array (for the C++ static destructors)
  43:../system/src/newlib/_startup.c **** // - call _exit(), directly or via exit()
  44:../system/src/newlib/_startup.c **** //
  45:../system/src/newlib/_startup.c **** // If OS_INCLUDE_STARTUP_INIT_MULTIPLE_RAM_SECTIONS is defined, the
  46:../system/src/newlib/_startup.c **** // code is capable of initialising multiple regions.
  47:../system/src/newlib/_startup.c **** //
  48:../system/src/newlib/_startup.c **** // The normal configuration is standalone, with all support
  49:../system/src/newlib/_startup.c **** // functions implemented locally.
  50:../system/src/newlib/_startup.c **** //
  51:../system/src/newlib/_startup.c **** // For this to be called, the project linker must be configured without
  52:../system/src/newlib/_startup.c **** // the startup sequence (-nostartfiles).
  53:../system/src/newlib/_startup.c **** 
  54:../system/src/newlib/_startup.c **** // ----------------------------------------------------------------------------
  55:../system/src/newlib/_startup.c **** 
  56:../system/src/newlib/_startup.c **** #include <stdint.h>
  57:../system/src/newlib/_startup.c **** #include <sys/types.h>
  58:../system/src/newlib/_startup.c **** 
  59:../system/src/newlib/_startup.c **** // ----------------------------------------------------------------------------
  60:../system/src/newlib/_startup.c **** 
  61:../system/src/newlib/_startup.c **** #if !defined(OS_INCLUDE_STARTUP_GUARD_CHECKS)
  62:../system/src/newlib/_startup.c **** #define OS_INCLUDE_STARTUP_GUARD_CHECKS (1)
  63:../system/src/newlib/_startup.c **** #endif
  64:../system/src/newlib/_startup.c **** 
  65:../system/src/newlib/_startup.c **** // ----------------------------------------------------------------------------
  66:../system/src/newlib/_startup.c **** 
  67:../system/src/newlib/_startup.c **** #if !defined(OS_INCLUDE_STARTUP_INIT_MULTIPLE_RAM_SECTIONS)
  68:../system/src/newlib/_startup.c **** // Begin address for the initialisation values of the .data section.
  69:../system/src/newlib/_startup.c **** // defined in linker script
  70:../system/src/newlib/_startup.c **** extern unsigned int _sidata;
  71:../system/src/newlib/_startup.c **** // Begin address for the .data section; defined in linker script
  72:../system/src/newlib/_startup.c **** extern unsigned int _sdata;
  73:../system/src/newlib/_startup.c **** // End address for the .data section; defined in linker script
  74:../system/src/newlib/_startup.c **** extern unsigned int _edata;
  75:../system/src/newlib/_startup.c **** 
  76:../system/src/newlib/_startup.c **** // Begin address for the .bss section; defined in linker script
  77:../system/src/newlib/_startup.c **** extern unsigned int __bss_start__;
  78:../system/src/newlib/_startup.c **** // End address for the .bss section; defined in linker script
  79:../system/src/newlib/_startup.c **** extern unsigned int __bss_end__;
  80:../system/src/newlib/_startup.c **** #else
  81:../system/src/newlib/_startup.c **** // The following symbols are constructs generated by the linker, indicating
  82:../system/src/newlib/_startup.c **** // the location of various points in the "Memory regions initialisation arrays".
  83:../system/src/newlib/_startup.c **** // These arrays are created by the linker via the managed linker script
  84:../system/src/newlib/_startup.c **** // of each RW data mechanism. It contains the load address, execution address
  85:../system/src/newlib/_startup.c **** // and length section and the execution and length of each BSS (zero
  86:../system/src/newlib/_startup.c **** // initialised) section.
  87:../system/src/newlib/_startup.c **** extern unsigned int __data_regions_array_start;
  88:../system/src/newlib/_startup.c **** extern unsigned int __data_regions_array_end;
  89:../system/src/newlib/_startup.c **** extern unsigned int __bss_regions_array_start;
  90:../system/src/newlib/_startup.c **** extern unsigned int __bss_regions_array_end;
  91:../system/src/newlib/_startup.c **** #endif
  92:../system/src/newlib/_startup.c **** 
  93:../system/src/newlib/_startup.c **** extern void
  94:../system/src/newlib/_startup.c **** __initialize_args (int*, char***);
  95:../system/src/newlib/_startup.c **** 
  96:../system/src/newlib/_startup.c **** // main() is the entry point for newlib based applications.
  97:../system/src/newlib/_startup.c **** // By default, there are no arguments, but this can be customised
  98:../system/src/newlib/_startup.c **** // by redefining __initialize_args(), which is done when the
  99:../system/src/newlib/_startup.c **** // semihosting configurations are used.
 100:../system/src/newlib/_startup.c **** extern int
 101:../system/src/newlib/_startup.c **** main (int argc, char* argv[]);
 102:../system/src/newlib/_startup.c **** 
 103:../system/src/newlib/_startup.c **** // The implementation for the exit routine; for embedded
 104:../system/src/newlib/_startup.c **** // applications, a system reset will be performed.
 105:../system/src/newlib/_startup.c **** extern void
 106:../system/src/newlib/_startup.c **** __attribute__((noreturn))
 107:../system/src/newlib/_startup.c **** _exit (int);
 108:../system/src/newlib/_startup.c **** 
 109:../system/src/newlib/_startup.c **** // ----------------------------------------------------------------------------
 110:../system/src/newlib/_startup.c **** 
 111:../system/src/newlib/_startup.c **** // Forward declarations
 112:../system/src/newlib/_startup.c **** 
 113:../system/src/newlib/_startup.c **** void
 114:../system/src/newlib/_startup.c **** _start (void);
 115:../system/src/newlib/_startup.c **** 
 116:../system/src/newlib/_startup.c **** void
 117:../system/src/newlib/_startup.c **** __initialize_data (unsigned int* from, unsigned int* region_begin,
 118:../system/src/newlib/_startup.c **** 		   unsigned int* region_end);
 119:../system/src/newlib/_startup.c **** 
 120:../system/src/newlib/_startup.c **** void
 121:../system/src/newlib/_startup.c **** __initialize_bss (unsigned int* region_begin, unsigned int* region_end);
 122:../system/src/newlib/_startup.c **** 
 123:../system/src/newlib/_startup.c **** void
 124:../system/src/newlib/_startup.c **** __run_init_array (void);
 125:../system/src/newlib/_startup.c **** 
 126:../system/src/newlib/_startup.c **** void
 127:../system/src/newlib/_startup.c **** __run_fini_array (void);
 128:../system/src/newlib/_startup.c **** 
 129:../system/src/newlib/_startup.c **** void
 130:../system/src/newlib/_startup.c **** __initialize_hardware_early (void);
 131:../system/src/newlib/_startup.c **** 
 132:../system/src/newlib/_startup.c **** void
 133:../system/src/newlib/_startup.c **** __initialize_hardware (void);
 134:../system/src/newlib/_startup.c **** 
 135:../system/src/newlib/_startup.c **** // ----------------------------------------------------------------------------
 136:../system/src/newlib/_startup.c **** 
 137:../system/src/newlib/_startup.c **** inline void
 138:../system/src/newlib/_startup.c **** __attribute__((always_inline))
 139:../system/src/newlib/_startup.c **** __initialize_data (unsigned int* from, unsigned int* region_begin,
 140:../system/src/newlib/_startup.c **** 		   unsigned int* region_end)
 141:../system/src/newlib/_startup.c **** {
  28              		.loc 1 141 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
 142:../system/src/newlib/_startup.c ****   // Iterate and copy word by word.
 143:../system/src/newlib/_startup.c ****   // It is assumed that the pointers are word aligned.
 144:../system/src/newlib/_startup.c ****   unsigned int *p = region_begin;
 145:../system/src/newlib/_startup.c ****   while (p < region_end)
  34              		.loc 1 145 0
  35 0000 03E0     		b	.L2
  36              	.LVL1:
  37              	.L3:
 146:../system/src/newlib/_startup.c ****     *p++ = *from++;
  38              		.loc 1 146 0
  39 0002 0368     		ldr	r3, [r0]
  40 0004 0B60     		str	r3, [r1]
  41 0006 0431     		adds	r1, r1, #4
  42              	.LVL2:
  43 0008 0430     		adds	r0, r0, #4
  44              	.LVL3:
  45              	.L2:
 145:../system/src/newlib/_startup.c ****     *p++ = *from++;
  46              		.loc 1 145 0
  47 000a 9142     		cmp	r1, r2
  48 000c F9D3     		bcc	.L3
 147:../system/src/newlib/_startup.c **** }
  49              		.loc 1 147 0
  50 000e 7047     		bx	lr
  51              		.cfi_endproc
  52              	.LFE0:
  54              		.section	.text.__initialize_bss,"ax",%progbits
  55              		.align	2
  56              		.global	__initialize_bss
  57              		.thumb
  58              		.thumb_func
  60              	__initialize_bss:
  61              	.LFB1:
 148:../system/src/newlib/_startup.c **** 
 149:../system/src/newlib/_startup.c **** inline void
 150:../system/src/newlib/_startup.c **** __attribute__((always_inline))
 151:../system/src/newlib/_startup.c **** __initialize_bss (unsigned int* region_begin, unsigned int* region_end)
 152:../system/src/newlib/_startup.c **** {
  62              		.loc 1 152 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 0
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67              	.LVL4:
 153:../system/src/newlib/_startup.c ****   // Iterate and clear word by word.
 154:../system/src/newlib/_startup.c ****   // It is assumed that the pointers are word aligned.
 155:../system/src/newlib/_startup.c ****   unsigned int *p = region_begin;
 156:../system/src/newlib/_startup.c ****   while (p < region_end)
  68              		.loc 1 156 0
  69 0000 02E0     		b	.L5
  70              	.LVL5:
  71              	.L6:
 157:../system/src/newlib/_startup.c ****     *p++ = 0;
  72              		.loc 1 157 0
  73 0002 0023     		movs	r3, #0
  74 0004 0360     		str	r3, [r0]
  75 0006 0430     		adds	r0, r0, #4
  76              	.LVL6:
  77              	.L5:
 156:../system/src/newlib/_startup.c ****     *p++ = 0;
  78              		.loc 1 156 0
  79 0008 8842     		cmp	r0, r1
  80 000a FAD3     		bcc	.L6
 158:../system/src/newlib/_startup.c **** }
  81              		.loc 1 158 0
  82 000c 7047     		bx	lr
  83              		.cfi_endproc
  84              	.LFE1:
  86 000e 00BF     		.section	.text.__run_init_array,"ax",%progbits
  87              		.align	2
  88              		.global	__run_init_array
  89              		.thumb
  90              		.thumb_func
  92              	__run_init_array:
  93              	.LFB2:
 159:../system/src/newlib/_startup.c **** 
 160:../system/src/newlib/_startup.c **** // These magic symbols are provided by the linker.
 161:../system/src/newlib/_startup.c **** extern void
 162:../system/src/newlib/_startup.c **** (*__preinit_array_start[]) (void) __attribute__((weak));
 163:../system/src/newlib/_startup.c **** extern void
 164:../system/src/newlib/_startup.c **** (*__preinit_array_end[]) (void) __attribute__((weak));
 165:../system/src/newlib/_startup.c **** extern void
 166:../system/src/newlib/_startup.c **** (*__init_array_start[]) (void) __attribute__((weak));
 167:../system/src/newlib/_startup.c **** extern void
 168:../system/src/newlib/_startup.c **** (*__init_array_end[]) (void) __attribute__((weak));
 169:../system/src/newlib/_startup.c **** extern void
 170:../system/src/newlib/_startup.c **** (*__fini_array_start[]) (void) __attribute__((weak));
 171:../system/src/newlib/_startup.c **** extern void
 172:../system/src/newlib/_startup.c **** (*__fini_array_end[]) (void) __attribute__((weak));
 173:../system/src/newlib/_startup.c **** 
 174:../system/src/newlib/_startup.c **** // Iterate over all the preinit/init routines (mainly static constructors).
 175:../system/src/newlib/_startup.c **** inline void
 176:../system/src/newlib/_startup.c **** __attribute__((always_inline))
 177:../system/src/newlib/_startup.c **** __run_init_array (void)
 178:../system/src/newlib/_startup.c **** {
  94              		.loc 1 178 0
  95              		.cfi_startproc
  96              		@ args = 0, pretend = 0, frame = 0
  97              		@ frame_needed = 0, uses_anonymous_args = 0
  98 0000 38B5     		push	{r3, r4, r5, lr}
  99              		.cfi_def_cfa_offset 16
 100              		.cfi_offset 3, -16
 101              		.cfi_offset 4, -12
 102              		.cfi_offset 5, -8
 103              		.cfi_offset 14, -4
 179:../system/src/newlib/_startup.c ****   int count;
 180:../system/src/newlib/_startup.c ****   int i;
 181:../system/src/newlib/_startup.c **** 
 182:../system/src/newlib/_startup.c ****   count = __preinit_array_end - __preinit_array_start;
 104              		.loc 1 182 0
 105 0002 0D4D     		ldr	r5, .L13
 106 0004 0D4B     		ldr	r3, .L13+4
 107 0006 5D1B     		subs	r5, r3, r5
 108 0008 AD10     		asrs	r5, r5, #2
 109              	.LVL7:
 183:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 110              		.loc 1 183 0
 111 000a 0024     		movs	r4, #0
 112 000c 04E0     		b	.L8
 113              	.LVL8:
 114              	.L9:
 184:../system/src/newlib/_startup.c ****     __preinit_array_start[i] ();
 115              		.loc 1 184 0 discriminator 3
 116 000e 0A4B     		ldr	r3, .L13
 117 0010 53F82430 		ldr	r3, [r3, r4, lsl #2]
 118 0014 9847     		blx	r3
 119              	.LVL9:
 183:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 120              		.loc 1 183 0 discriminator 3
 121 0016 0134     		adds	r4, r4, #1
 122              	.LVL10:
 123              	.L8:
 183:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 124              		.loc 1 183 0 is_stmt 0 discriminator 1
 125 0018 AC42     		cmp	r4, r5
 126 001a F8DB     		blt	.L9
 185:../system/src/newlib/_startup.c **** 
 186:../system/src/newlib/_startup.c ****   // If you need to run the code in the .init section, please use
 187:../system/src/newlib/_startup.c ****   // the startup files, since this requires the code in crti.o and crtn.o
 188:../system/src/newlib/_startup.c ****   // to add the function prologue/epilogue.
 189:../system/src/newlib/_startup.c ****   //_init(); // DO NOT ENABE THIS!
 190:../system/src/newlib/_startup.c **** 
 191:../system/src/newlib/_startup.c ****   count = __init_array_end - __init_array_start;
 127              		.loc 1 191 0 is_stmt 1
 128 001c 084D     		ldr	r5, .L13+8
 129              	.LVL11:
 130 001e 094B     		ldr	r3, .L13+12
 131 0020 5D1B     		subs	r5, r3, r5
 132 0022 AD10     		asrs	r5, r5, #2
 133              	.LVL12:
 192:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 134              		.loc 1 192 0
 135 0024 0024     		movs	r4, #0
 136 0026 04E0     		b	.L10
 137              	.LVL13:
 138              	.L11:
 193:../system/src/newlib/_startup.c ****     __init_array_start[i] ();
 139              		.loc 1 193 0 discriminator 3
 140 0028 054B     		ldr	r3, .L13+8
 141 002a 53F82430 		ldr	r3, [r3, r4, lsl #2]
 142 002e 9847     		blx	r3
 143              	.LVL14:
 192:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 144              		.loc 1 192 0 discriminator 3
 145 0030 0134     		adds	r4, r4, #1
 146              	.LVL15:
 147              	.L10:
 192:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 148              		.loc 1 192 0 is_stmt 0 discriminator 1
 149 0032 AC42     		cmp	r4, r5
 150 0034 F8DB     		blt	.L11
 194:../system/src/newlib/_startup.c **** }
 151              		.loc 1 194 0 is_stmt 1
 152 0036 38BD     		pop	{r3, r4, r5, pc}
 153              	.LVL16:
 154              	.L14:
 155              		.align	2
 156              	.L13:
 157 0038 00000000 		.word	__preinit_array_start
 158 003c 00000000 		.word	__preinit_array_end
 159 0040 00000000 		.word	__init_array_start
 160 0044 00000000 		.word	__init_array_end
 161              		.cfi_endproc
 162              	.LFE2:
 164              		.section	.text.__run_fini_array,"ax",%progbits
 165              		.align	2
 166              		.global	__run_fini_array
 167              		.thumb
 168              		.thumb_func
 170              	__run_fini_array:
 171              	.LFB3:
 195:../system/src/newlib/_startup.c **** 
 196:../system/src/newlib/_startup.c **** // Run all the cleanup routines (mainly static destructors).
 197:../system/src/newlib/_startup.c **** inline void
 198:../system/src/newlib/_startup.c **** __attribute__((always_inline))
 199:../system/src/newlib/_startup.c **** __run_fini_array (void)
 200:../system/src/newlib/_startup.c **** {
 172              		.loc 1 200 0
 173              		.cfi_startproc
 174              		@ args = 0, pretend = 0, frame = 0
 175              		@ frame_needed = 0, uses_anonymous_args = 0
 176 0000 10B5     		push	{r4, lr}
 177              		.cfi_def_cfa_offset 8
 178              		.cfi_offset 4, -8
 179              		.cfi_offset 14, -4
 201:../system/src/newlib/_startup.c ****   int count;
 202:../system/src/newlib/_startup.c ****   int i;
 203:../system/src/newlib/_startup.c **** 
 204:../system/src/newlib/_startup.c ****   count = __fini_array_end - __fini_array_start;
 180              		.loc 1 204 0
 181 0002 064C     		ldr	r4, .L19
 182 0004 064B     		ldr	r3, .L19+4
 183 0006 1C1B     		subs	r4, r3, r4
 184 0008 A410     		asrs	r4, r4, #2
 185              	.LVL17:
 205:../system/src/newlib/_startup.c ****   for (i = count; i > 0; i--)
 186              		.loc 1 205 0
 187 000a 04E0     		b	.L16
 188              	.LVL18:
 189              	.L17:
 206:../system/src/newlib/_startup.c ****     __fini_array_start[i - 1] ();
 190              		.loc 1 206 0 discriminator 3
 191 000c 013C     		subs	r4, r4, #1
 192              	.LVL19:
 193 000e 034B     		ldr	r3, .L19
 194              	.LVL20:
 195 0010 53F82430 		ldr	r3, [r3, r4, lsl #2]
 196              	.LVL21:
 197 0014 9847     		blx	r3
 198              	.LVL22:
 199              	.L16:
 205:../system/src/newlib/_startup.c ****   for (i = count; i > 0; i--)
 200              		.loc 1 205 0 discriminator 1
 201 0016 002C     		cmp	r4, #0
 202 0018 F8DC     		bgt	.L17
 207:../system/src/newlib/_startup.c **** 
 208:../system/src/newlib/_startup.c ****   // If you need to run the code in the .fini section, please use
 209:../system/src/newlib/_startup.c ****   // the startup files, since this requires the code in crti.o and crtn.o
 210:../system/src/newlib/_startup.c ****   // to add the function prologue/epilogue.
 211:../system/src/newlib/_startup.c ****   //_fini(); // DO NOT ENABE THIS!
 212:../system/src/newlib/_startup.c **** }
 203              		.loc 1 212 0
 204 001a 10BD     		pop	{r4, pc}
 205              	.LVL23:
 206              	.L20:
 207              		.align	2
 208              	.L19:
 209 001c 00000000 		.word	__fini_array_start
 210 0020 00000000 		.word	__fini_array_end
 211              		.cfi_endproc
 212              	.LFE3:
 214              		.section	.after_vectors,"ax",%progbits
 215              		.align	2
 216              		.weak	_start
 217              		.thumb
 218              		.thumb_func
 220              	_start:
 221              	.LFB4:
 213:../system/src/newlib/_startup.c **** 
 214:../system/src/newlib/_startup.c **** #if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
 215:../system/src/newlib/_startup.c **** 
 216:../system/src/newlib/_startup.c **** // These definitions are used to check if the routines used to
 217:../system/src/newlib/_startup.c **** // clear the BSS and to copy the initialised DATA perform correctly.
 218:../system/src/newlib/_startup.c **** 
 219:../system/src/newlib/_startup.c **** #define BSS_GUARD_BAD_VALUE (0xCADEBABA)
 220:../system/src/newlib/_startup.c **** 
 221:../system/src/newlib/_startup.c **** static uint32_t volatile __attribute__ ((section(".bss_begin")))
 222:../system/src/newlib/_startup.c **** __bss_begin_guard;
 223:../system/src/newlib/_startup.c **** static uint32_t volatile __attribute__ ((section(".bss_end")))
 224:../system/src/newlib/_startup.c **** __bss_end_guard;
 225:../system/src/newlib/_startup.c **** 
 226:../system/src/newlib/_startup.c **** #define DATA_GUARD_BAD_VALUE (0xCADEBABA)
 227:../system/src/newlib/_startup.c **** #define DATA_BEGIN_GUARD_VALUE (0x12345678)
 228:../system/src/newlib/_startup.c **** #define DATA_END_GUARD_VALUE (0x98765432)
 229:../system/src/newlib/_startup.c **** 
 230:../system/src/newlib/_startup.c **** static uint32_t volatile __attribute__ ((section(".data_begin")))
 231:../system/src/newlib/_startup.c **** __data_begin_guard = DATA_BEGIN_GUARD_VALUE;
 232:../system/src/newlib/_startup.c **** 
 233:../system/src/newlib/_startup.c **** static uint32_t volatile __attribute__ ((section(".data_end")))
 234:../system/src/newlib/_startup.c **** __data_end_guard = DATA_END_GUARD_VALUE;
 235:../system/src/newlib/_startup.c **** 
 236:../system/src/newlib/_startup.c **** #endif // defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
 237:../system/src/newlib/_startup.c **** 
 238:../system/src/newlib/_startup.c **** // This is the place where Cortex-M core will go immediately after reset,
 239:../system/src/newlib/_startup.c **** // via a call or jump from the Reset_Handler.
 240:../system/src/newlib/_startup.c **** //
 241:../system/src/newlib/_startup.c **** // For the call to work, and for the call to __initialize_hardware_early()
 242:../system/src/newlib/_startup.c **** // to work, the reset stack must point to a valid internal RAM area.
 243:../system/src/newlib/_startup.c **** 
 244:../system/src/newlib/_startup.c **** void __attribute__ ((section(".after_vectors"),noreturn,weak))
 245:../system/src/newlib/_startup.c **** _start (void)
 246:../system/src/newlib/_startup.c **** {
 222              		.loc 1 246 0
 223              		.cfi_startproc
 224              		@ Volatile: function does not return.
 225              		@ args = 0, pretend = 0, frame = 8
 226              		@ frame_needed = 0, uses_anonymous_args = 0
 227 0000 00B5     		push	{lr}
 228              		.cfi_def_cfa_offset 4
 229              		.cfi_offset 14, -4
 230 0002 83B0     		sub	sp, sp, #12
 231              		.cfi_def_cfa_offset 16
 247:../system/src/newlib/_startup.c **** 
 248:../system/src/newlib/_startup.c ****   // Initialise hardware right after reset, to switch clock to higher
 249:../system/src/newlib/_startup.c ****   // frequency and have the rest of the initialisations run faster.
 250:../system/src/newlib/_startup.c ****   //
 251:../system/src/newlib/_startup.c ****   // Mandatory on platforms like Kinetis, which start with the watch dog
 252:../system/src/newlib/_startup.c ****   // enabled and require an early sequence to disable it.
 253:../system/src/newlib/_startup.c ****   //
 254:../system/src/newlib/_startup.c ****   // Also useful on platform with external RAM, that need to be
 255:../system/src/newlib/_startup.c ****   // initialised before filling the BSS section.
 256:../system/src/newlib/_startup.c **** 
 257:../system/src/newlib/_startup.c ****   __initialize_hardware_early ();
 232              		.loc 1 257 0
 233 0004 FFF7FEFF 		bl	__initialize_hardware_early
 234              	.LVL24:
 258:../system/src/newlib/_startup.c **** 
 259:../system/src/newlib/_startup.c ****   // Use Old Style DATA and BSS section initialisation,
 260:../system/src/newlib/_startup.c ****   // that will manage a single BSS sections.
 261:../system/src/newlib/_startup.c **** 
 262:../system/src/newlib/_startup.c **** #if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
 263:../system/src/newlib/_startup.c ****   __data_begin_guard = DATA_GUARD_BAD_VALUE;
 235              		.loc 1 263 0
 236 0008 384B     		ldr	r3, .L41
 237 000a 394A     		ldr	r2, .L41+4
 238 000c 1360     		str	r3, [r2]
 264:../system/src/newlib/_startup.c ****   __data_end_guard = DATA_GUARD_BAD_VALUE;
 239              		.loc 1 264 0
 240 000e 394A     		ldr	r2, .L41+8
 241 0010 1360     		str	r3, [r2]
 242              	.LVL25:
 243              	.LBB14:
 265:../system/src/newlib/_startup.c **** #endif
 266:../system/src/newlib/_startup.c **** 
 267:../system/src/newlib/_startup.c **** #if !defined(OS_INCLUDE_STARTUP_INIT_MULTIPLE_RAM_SECTIONS)
 268:../system/src/newlib/_startup.c ****   // Copy the DATA segment from Flash to RAM (inlined).
 269:../system/src/newlib/_startup.c ****   __initialize_data(&_sidata, &_sdata, &_edata);
 270:../system/src/newlib/_startup.c **** #else
 271:../system/src/newlib/_startup.c **** 
 272:../system/src/newlib/_startup.c ****   // Copy the data sections from flash to SRAM.
 273:../system/src/newlib/_startup.c ****   for (unsigned int* p = &__data_regions_array_start;
 244              		.loc 1 273 0
 245 0012 3949     		ldr	r1, .L41+12
 246 0014 0CE0     		b	.L22
 247              	.LVL26:
 248              	.L25:
 249              	.LBB15:
 274:../system/src/newlib/_startup.c ****       p < &__data_regions_array_end;)
 275:../system/src/newlib/_startup.c ****     {
 276:../system/src/newlib/_startup.c ****       unsigned int* from = (unsigned int *) (*p++);
 250              		.loc 1 276 0
 251 0016 0A68     		ldr	r2, [r1]
 252              	.LVL27:
 277:../system/src/newlib/_startup.c ****       unsigned int* region_begin = (unsigned int *) (*p++);
 253              		.loc 1 277 0
 254 0018 4B68     		ldr	r3, [r1, #4]
 255              	.LVL28:
 278:../system/src/newlib/_startup.c ****       unsigned int* region_end = (unsigned int *) (*p++);
 256              		.loc 1 278 0
 257 001a 01F10C04 		add	r4, r1, #12
 258              	.LVL29:
 259 001e 8868     		ldr	r0, [r1, #8]
 260              	.LVL30:
 261 0020 03E0     		b	.L23
 262              	.LVL31:
 263              	.L24:
 264              	.LBB16:
 265              	.LBB17:
 146:../system/src/newlib/_startup.c **** }
 266              		.loc 1 146 0
 267 0022 1168     		ldr	r1, [r2]
 268 0024 1960     		str	r1, [r3]
 269 0026 0433     		adds	r3, r3, #4
 270              	.LVL32:
 271 0028 0432     		adds	r2, r2, #4
 272              	.LVL33:
 273              	.L23:
 145:../system/src/newlib/_startup.c ****     *p++ = *from++;
 274              		.loc 1 145 0
 275 002a 9842     		cmp	r0, r3
 276 002c F9D8     		bhi	.L24
 277              	.LBE17:
 278              	.LBE16:
 279              		.loc 1 278 0
 280 002e 2146     		mov	r1, r4
 281              	.LVL34:
 282              	.L22:
 283              	.LBE15:
 273:../system/src/newlib/_startup.c ****       p < &__data_regions_array_end;)
 284              		.loc 1 273 0 discriminator 1
 285 0030 324B     		ldr	r3, .L41+16
 286 0032 9942     		cmp	r1, r3
 287 0034 EFD3     		bcc	.L25
 288              	.LBE14:
 279:../system/src/newlib/_startup.c **** 
 280:../system/src/newlib/_startup.c ****       __initialize_data (from, region_begin, region_end);
 281:../system/src/newlib/_startup.c ****     }
 282:../system/src/newlib/_startup.c **** 
 283:../system/src/newlib/_startup.c **** #endif
 284:../system/src/newlib/_startup.c **** 
 285:../system/src/newlib/_startup.c **** #if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
 286:../system/src/newlib/_startup.c ****   if ((__data_begin_guard != DATA_BEGIN_GUARD_VALUE)
 289              		.loc 1 286 0
 290 0036 2E4B     		ldr	r3, .L41+4
 291 0038 1A68     		ldr	r2, [r3]
 292 003a 314B     		ldr	r3, .L41+20
 293 003c 9A42     		cmp	r2, r3
 294 003e 04D1     		bne	.L26
 287:../system/src/newlib/_startup.c ****       || (__data_end_guard != DATA_END_GUARD_VALUE))
 295              		.loc 1 287 0
 296 0040 2C4B     		ldr	r3, .L41+8
 297 0042 1A68     		ldr	r2, [r3]
 298 0044 2F4B     		ldr	r3, .L41+24
 299 0046 9A42     		cmp	r2, r3
 300 0048 00D0     		beq	.L27
 301              	.L26:
 302 004a FEE7     		b	.L26
 303              	.L27:
 288:../system/src/newlib/_startup.c ****     {
 289:../system/src/newlib/_startup.c ****       for (;;)
 290:../system/src/newlib/_startup.c **** 	;
 291:../system/src/newlib/_startup.c ****     }
 292:../system/src/newlib/_startup.c **** #endif
 293:../system/src/newlib/_startup.c **** 
 294:../system/src/newlib/_startup.c **** #if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
 295:../system/src/newlib/_startup.c ****   __bss_begin_guard = BSS_GUARD_BAD_VALUE;
 304              		.loc 1 295 0
 305 004c 274B     		ldr	r3, .L41
 306 004e 2E4A     		ldr	r2, .L41+28
 307 0050 1360     		str	r3, [r2]
 296:../system/src/newlib/_startup.c ****   __bss_end_guard = BSS_GUARD_BAD_VALUE;
 308              		.loc 1 296 0
 309 0052 2E4A     		ldr	r2, .L41+32
 310 0054 1360     		str	r3, [r2]
 311              	.LVL35:
 312              	.LBB18:
 297:../system/src/newlib/_startup.c **** #endif
 298:../system/src/newlib/_startup.c **** 
 299:../system/src/newlib/_startup.c **** #if !defined(OS_INCLUDE_STARTUP_INIT_MULTIPLE_RAM_SECTIONS)
 300:../system/src/newlib/_startup.c ****   // Zero fill the BSS section (inlined).
 301:../system/src/newlib/_startup.c ****   __initialize_bss(&__bss_start__, &__bss_end__);
 302:../system/src/newlib/_startup.c **** #else
 303:../system/src/newlib/_startup.c **** 
 304:../system/src/newlib/_startup.c ****   // Zero fill all bss segments
 305:../system/src/newlib/_startup.c ****   for (unsigned int *p = &__bss_regions_array_start;
 313              		.loc 1 305 0
 314 0056 2E4B     		ldr	r3, .L41+36
 315 0058 0AE0     		b	.L28
 316              	.LVL36:
 317              	.L31:
 318              	.LBB19:
 306:../system/src/newlib/_startup.c ****       p < &__bss_regions_array_end;)
 307:../system/src/newlib/_startup.c ****     {
 308:../system/src/newlib/_startup.c ****       unsigned int* region_begin = (unsigned int*) (*p++);
 319              		.loc 1 308 0
 320 005a 1946     		mov	r1, r3
 321 005c 51F8082B 		ldr	r2, [r1], #8
 322              	.LVL37:
 309:../system/src/newlib/_startup.c ****       unsigned int* region_end = (unsigned int*) (*p++);
 323              		.loc 1 309 0
 324 0060 5B68     		ldr	r3, [r3, #4]
 325              	.LVL38:
 326 0062 02E0     		b	.L29
 327              	.LVL39:
 328              	.L30:
 329              	.LBB20:
 330              	.LBB21:
 157:../system/src/newlib/_startup.c **** }
 331              		.loc 1 157 0
 332 0064 0020     		movs	r0, #0
 333 0066 1060     		str	r0, [r2]
 334 0068 0432     		adds	r2, r2, #4
 335              	.LVL40:
 336              	.L29:
 156:../system/src/newlib/_startup.c ****     *p++ = 0;
 337              		.loc 1 156 0
 338 006a 9A42     		cmp	r2, r3
 339 006c FAD3     		bcc	.L30
 340              	.LBE21:
 341              	.LBE20:
 342              		.loc 1 309 0
 343 006e 0B46     		mov	r3, r1
 344              	.LVL41:
 345              	.L28:
 346              	.LBE19:
 305:../system/src/newlib/_startup.c ****       p < &__bss_regions_array_end;)
 347              		.loc 1 305 0 discriminator 1
 348 0070 284A     		ldr	r2, .L41+40
 349 0072 9342     		cmp	r3, r2
 350 0074 F1D3     		bcc	.L31
 351              	.LBE18:
 310:../system/src/newlib/_startup.c ****       __initialize_bss (region_begin, region_end);
 311:../system/src/newlib/_startup.c ****     }
 312:../system/src/newlib/_startup.c **** #endif
 313:../system/src/newlib/_startup.c **** 
 314:../system/src/newlib/_startup.c **** #if defined(DEBUG) && (OS_INCLUDE_STARTUP_GUARD_CHECKS)
 315:../system/src/newlib/_startup.c ****   if ((__bss_begin_guard != 0) || (__bss_end_guard != 0))
 352              		.loc 1 315 0
 353 0076 244B     		ldr	r3, .L41+28
 354              	.LVL42:
 355 0078 1B68     		ldr	r3, [r3]
 356 007a 13B9     		cbnz	r3, .L32
 357              		.loc 1 315 0 is_stmt 0 discriminator 1
 358 007c 234B     		ldr	r3, .L41+32
 359 007e 1B68     		ldr	r3, [r3]
 360 0080 03B1     		cbz	r3, .L33
 361              	.L32:
 362 0082 FEE7     		b	.L32
 363              	.L33:
 316:../system/src/newlib/_startup.c ****     {
 317:../system/src/newlib/_startup.c ****       for (;;)
 318:../system/src/newlib/_startup.c **** 	;
 319:../system/src/newlib/_startup.c ****     }
 320:../system/src/newlib/_startup.c **** #endif
 321:../system/src/newlib/_startup.c **** 
 322:../system/src/newlib/_startup.c ****   // Hook to continue the initialisations. Usually compute and store the
 323:../system/src/newlib/_startup.c ****   // clock frequency in the global CMSIS variable, cleared above.
 324:../system/src/newlib/_startup.c ****   __initialize_hardware ();
 364              		.loc 1 324 0 is_stmt 1
 365 0084 FFF7FEFF 		bl	__initialize_hardware
 366              	.LVL43:
 325:../system/src/newlib/_startup.c **** 
 326:../system/src/newlib/_startup.c ****   // Get the argc/argv (useful in semihosting configurations).
 327:../system/src/newlib/_startup.c ****   int argc;
 328:../system/src/newlib/_startup.c ****   char** argv;
 329:../system/src/newlib/_startup.c ****   __initialize_args (&argc, &argv);
 367              		.loc 1 329 0
 368 0088 6946     		mov	r1, sp
 369 008a 01A8     		add	r0, sp, #4
 370 008c FFF7FEFF 		bl	__initialize_args
 371              	.LVL44:
 372              	.LBB22:
 373              	.LBB23:
 182:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 374              		.loc 1 182 0
 375 0090 214C     		ldr	r4, .L41+44
 376 0092 224B     		ldr	r3, .L41+48
 377 0094 1C1B     		subs	r4, r3, r4
 378 0096 A410     		asrs	r4, r4, #2
 379              	.LVL45:
 183:../system/src/newlib/_startup.c ****     __preinit_array_start[i] ();
 380              		.loc 1 183 0
 381 0098 0025     		movs	r5, #0
 382 009a 04E0     		b	.L34
 383              	.LVL46:
 384              	.L35:
 184:../system/src/newlib/_startup.c **** 
 385              		.loc 1 184 0
 386 009c 1E4B     		ldr	r3, .L41+44
 387 009e 53F82530 		ldr	r3, [r3, r5, lsl #2]
 388 00a2 9847     		blx	r3
 389              	.LVL47:
 183:../system/src/newlib/_startup.c ****     __preinit_array_start[i] ();
 390              		.loc 1 183 0
 391 00a4 0135     		adds	r5, r5, #1
 392              	.LVL48:
 393              	.L34:
 394 00a6 AC42     		cmp	r4, r5
 395 00a8 F8DC     		bgt	.L35
 191:../system/src/newlib/_startup.c ****   for (i = 0; i < count; i++)
 396              		.loc 1 191 0
 397 00aa 1D4C     		ldr	r4, .L41+52
 398              	.LVL49:
 399 00ac 1D4B     		ldr	r3, .L41+56
 400 00ae 1C1B     		subs	r4, r3, r4
 401 00b0 A410     		asrs	r4, r4, #2
 402              	.LVL50:
 192:../system/src/newlib/_startup.c ****     __init_array_start[i] ();
 403              		.loc 1 192 0
 404 00b2 0025     		movs	r5, #0
 405 00b4 04E0     		b	.L36
 406              	.LVL51:
 407              	.L37:
 193:../system/src/newlib/_startup.c **** }
 408              		.loc 1 193 0
 409 00b6 1A4B     		ldr	r3, .L41+52
 410 00b8 53F82530 		ldr	r3, [r3, r5, lsl #2]
 411 00bc 9847     		blx	r3
 412              	.LVL52:
 192:../system/src/newlib/_startup.c ****     __init_array_start[i] ();
 413              		.loc 1 192 0
 414 00be 0135     		adds	r5, r5, #1
 415              	.LVL53:
 416              	.L36:
 417 00c0 AC42     		cmp	r4, r5
 418 00c2 F8DC     		bgt	.L37
 419              	.LVL54:
 420              	.LBE23:
 421              	.LBE22:
 330:../system/src/newlib/_startup.c **** 
 331:../system/src/newlib/_startup.c ****   // Call the standard library initialisation (mandatory for C++ to
 332:../system/src/newlib/_startup.c ****   // execute the constructors for the static objects).
 333:../system/src/newlib/_startup.c ****   __run_init_array ();
 334:../system/src/newlib/_startup.c **** 
 335:../system/src/newlib/_startup.c ****   // Call the main entry point, and save the exit code.
 336:../system/src/newlib/_startup.c ****   int code = main (argc, argv);
 422              		.loc 1 336 0
 423 00c4 0099     		ldr	r1, [sp]
 424 00c6 0198     		ldr	r0, [sp, #4]
 425 00c8 FFF7FEFF 		bl	main
 426              	.LVL55:
 427 00cc 0546     		mov	r5, r0
 428              	.LVL56:
 429              	.LBB24:
 430              	.LBB25:
 204:../system/src/newlib/_startup.c ****   for (i = count; i > 0; i--)
 431              		.loc 1 204 0
 432 00ce 164C     		ldr	r4, .L41+60
 433 00d0 164B     		ldr	r3, .L41+64
 434 00d2 1C1B     		subs	r4, r3, r4
 435 00d4 A410     		asrs	r4, r4, #2
 436              	.LVL57:
 437 00d6 04E0     		b	.L38
 438              	.LVL58:
 439              	.L39:
 206:../system/src/newlib/_startup.c **** 
 440              		.loc 1 206 0
 441 00d8 013C     		subs	r4, r4, #1
 442              	.LVL59:
 443 00da 134B     		ldr	r3, .L41+60
 444              	.LVL60:
 445 00dc 53F82430 		ldr	r3, [r3, r4, lsl #2]
 446              	.LVL61:
 447 00e0 9847     		blx	r3
 448              	.LVL62:
 449              	.L38:
 205:../system/src/newlib/_startup.c ****     __fini_array_start[i - 1] ();
 450              		.loc 1 205 0
 451 00e2 002C     		cmp	r4, #0
 452 00e4 F8DC     		bgt	.L39
 453              	.LVL63:
 454              	.LBE25:
 455              	.LBE24:
 337:../system/src/newlib/_startup.c **** 
 338:../system/src/newlib/_startup.c ****   // Run the C++ static destructors.
 339:../system/src/newlib/_startup.c ****   __run_fini_array ();
 340:../system/src/newlib/_startup.c **** 
 341:../system/src/newlib/_startup.c ****   _exit (code);
 456              		.loc 1 341 0
 457 00e6 2846     		mov	r0, r5
 458 00e8 FFF7FEFF 		bl	_exit
 459              	.LVL64:
 460              	.L42:
 461              		.align	2
 462              	.L41:
 463 00ec BABADECA 		.word	-891372870
 464 00f0 00000000 		.word	.LANCHOR0
 465 00f4 00000000 		.word	.LANCHOR1
 466 00f8 00000000 		.word	__data_regions_array_start
 467 00fc 00000000 		.word	__data_regions_array_end
 468 0100 78563412 		.word	305419896
 469 0104 32547698 		.word	-1737075662
 470 0108 00000000 		.word	.LANCHOR2
 471 010c 00000000 		.word	.LANCHOR3
 472 0110 00000000 		.word	__bss_regions_array_start
 473 0114 00000000 		.word	__bss_regions_array_end
 474 0118 00000000 		.word	__preinit_array_start
 475 011c 00000000 		.word	__preinit_array_end
 476 0120 00000000 		.word	__init_array_start
 477 0124 00000000 		.word	__init_array_end
 478 0128 00000000 		.word	__fini_array_start
 479 012c 00000000 		.word	__fini_array_end
 480              		.cfi_endproc
 481              	.LFE4:
 483              		.section	.bss_begin,"aw",%progbits
 484              		.align	2
 485              		.set	.LANCHOR2,. + 0
 488              	__bss_begin_guard:
 489 0000 00000000 		.space	4
 490              		.section	.data_end,"aw",%progbits
 491              		.align	2
 492              		.set	.LANCHOR1,. + 0
 495              	__data_end_guard:
 496 0000 32547698 		.word	-1737075662
 497              		.section	.bss_end,"aw",%progbits
 498              		.align	2
 499              		.set	.LANCHOR3,. + 0
 502              	__bss_end_guard:
 503 0000 00000000 		.space	4
 504              		.section	.data_begin,"aw",%progbits
 505              		.align	2
 506              		.set	.LANCHOR0,. + 0
 509              	__data_begin_guard:
 510 0000 78563412 		.word	305419896
 511              		.weak	__fini_array_end
 512              		.weak	__fini_array_start
 513              		.weak	__init_array_end
 514              		.weak	__init_array_start
 515              		.weak	__preinit_array_end
 516              		.weak	__preinit_array_start
 517              		.text
 518              	.Letext0:
 519              		.file 2 "e:\\iti_9_months\\embeddedsystems\\tourkey\\tools\\arm gcc\\lib\\gcc\\arm-none-eabi\\5.4.
DEFINED SYMBOLS
                            *ABS*:00000000 _startup.c
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:20     .text.__initialize_data:00000000 $t
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:25     .text.__initialize_data:00000000 __initialize_data
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:55     .text.__initialize_bss:00000000 $t
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:60     .text.__initialize_bss:00000000 __initialize_bss
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:87     .text.__run_init_array:00000000 $t
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:92     .text.__run_init_array:00000000 __run_init_array
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:157    .text.__run_init_array:00000038 $d
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:165    .text.__run_fini_array:00000000 $t
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:170    .text.__run_fini_array:00000000 __run_fini_array
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:209    .text.__run_fini_array:0000001c $d
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:215    .after_vectors:00000000 $t
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:220    .after_vectors:00000000 _start
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:463    .after_vectors:000000ec $d
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:484    .bss_begin:00000000 $d
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:488    .bss_begin:00000000 __bss_begin_guard
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:491    .data_end:00000000 $d
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:495    .data_end:00000000 __data_end_guard
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:498    .bss_end:00000000 $d
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:502    .bss_end:00000000 __bss_end_guard
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:505    .data_begin:00000000 $d
C:\Users\NoteBook\AppData\Local\Temp\ccwAmoeH.s:509    .data_begin:00000000 __data_begin_guard
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.997b4815c781b0e489bb2254d160a080
                           .group:00000000 wm4.stdintgcc.h.29.6d480f4ba0f60596e88234283d42444f
                           .group:00000000 wm4._newlib_version.h.4.ad342815780c8db09778091a421b5b5b
                           .group:00000000 wm4.newlib.h.21.0b9fc973bddc8b940a18de2b6ea6adc7
                           .group:00000000 wm4.features.h.22.5cdadbb3efe495d1c9e38350b8c376c7
                           .group:00000000 wm4.config.h.219.65a553ab5bef5482f0d7880b0d33015e
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4.stddef.h.39.a38874c8f8a57e66301090908ec2a69f
                           .group:00000000 wm4.cdefs.h.47.ba62642086d429b4f95c2381cae1c0aa
                           .group:00000000 wm4.types.h.40.e8c16e7ec36ba55f133d0616070e25fc
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.125.5cf8a495f1f7ef36777ad868a1e32068
                           .group:00000000 wm4.stddef.h.161.5349cb105733e8777bfb0cf53c4e3f34
                           .group:00000000 wm4._types.h.183.c226d164ceca1f2ecb9ae9360c54a098
                           .group:00000000 wm4._stdint.h.10.7a5f60e6741af4a5594a3867d347e1f9
                           .group:00000000 wm4._endian.h.31.65a10590763c3dde1ac4a7f66d7d4891
                           .group:00000000 wm4.endian.h.9.49f3a4695c1b61e8a0808de3c4a106cb
                           .group:00000000 wm4._timeval.h.30.0e8bfd94e85db17dda3286ee81496fe6
                           .group:00000000 wm4.timespec.h.41.d855182eb0e690443ab8651bcedca6e1
                           .group:00000000 wm4.select.h.30.bbece7fa40993a78092dcc5805132560
                           .group:00000000 wm4.types.h.69.ed3eae3cf73030a737515151ebcab7a1

UNDEFINED SYMBOLS
__preinit_array_start
__preinit_array_end
__init_array_start
__init_array_end
__fini_array_start
__fini_array_end
__initialize_hardware_early
__initialize_hardware
__initialize_args
main
_exit
__data_regions_array_start
__data_regions_array_end
__bss_regions_array_start
__bss_regions_array_end
